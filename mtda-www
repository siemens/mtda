#!/usr/bin/env python3
# ---------------------------------------------------------------------------
# Web service for MTDA
# ---------------------------------------------------------------------------
#
# This software is a part of MTDA.
# Copyright (C) 2025 Siemens AG
#
# ---------------------------------------------------------------------------
# SPDX-License-Identifier: MIT
# ---------------------------------------------------------------------------

import argparse
import asyncio
import base64
import json
import tornado.web
import tornado.websocket
import tornado.ioloop
import tornado.escape
import os
import uuid
import zmq.asyncio
import concurrent.futures
import logging
import functools

from mtda.client import Client
from mtda.utils import Compression
import mtda.constants as CONSTS
from mtda.console.remote import RemoteConsole
from mtda.console.screen import ScreenOutput

# Pyro
try:
    import Pyro5.errors as PyroErrors
except ImportError:
    import Pyro4.errors as PyroErrors

# ---------------------------------------------------------------------------
# Configure basic logging for better visibility of errors
# ---------------------------------------------------------------------------


logging.basicConfig(level=logging.INFO,
                    format='# %(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Utility decorator for remote call execution
# ---------------------------------------------------------------------------


def remote_call(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        mtda = Client("localhost")
        return func(mtda, *args, **kwargs)
    return wrapper

# ---------------------------------------------------------------------------
# Core Tornado Handlers (not directly interacting with MTDA)
# ---------------------------------------------------------------------------


class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.render("index.html")


class AssetsHandler(tornado.web.StaticFileHandler):
    pass


class NoVNCHandler(tornado.web.StaticFileHandler):
    pass


class PyodideHandler(tornado.web.StaticFileHandler):
    pass


class WheelHandler(tornado.web.StaticFileHandler):
    pass


class BaseHandler(tornado.web.RequestHandler):
    """
    Base handler providing a utility method for JSON responses.
    """
    def result_as_json(self, result):
        response = {"result": result}
        self.set_header("Content-Type", "application/json")
        self.write(json.dumps(response))


class RemoteCallHandler(BaseHandler):
    """
    Base handler for API endpoints that interact with remote services
    Handles common logic for offloading blocking calls to a thread pool
    and centralized error handling for remote interactions.
    """
    async def get(self):
        try:
            logger.debug(f"Request: {self.__class__.__name__}")
            status, response = await self._handle_remote_request()
            logger.debug(f"{self.__class__.__name__} status {status}, response {response}")
            self.set_status(status)
            # For 204 No Content, we just set status and finish, no body needed
            if response is not None:
                self.result_as_json(response)
        except PyroErrors.TimeoutError:
            logger.warning("Remote service timed out for "
                           f"{self.__class__.__name__}")
            self.set_status(504)  # Gateway Timeout
            self.write({"error": "Remote service timed out."})
        except Exception as e:
            logger.exception(f"Unhandled error in {self.__class__.__name__}: {e}")
            self.set_status(500)
            self.write({"error": str(e)})
        finally:
            self.finish()

    async def blocking_call(self, func, *args, **kwargs):
        """
        Shorthand to run a blocking function in the application's
        ThreadPoolExecutor.  Automatically uses functools.partial
        to handle arguments.
        """
        return await tornado.ioloop.IOLoop.current().run_in_executor(
            self.application.executor,
            functools.partial(func, *args, **kwargs)
        )

    async def _handle_remote_request(self):
        """
        Abstract method to be implemented by subclasses.
        This method should contain the specific logic for interacting
        with the remote service. It should parse its own arguments
        (using self.get_argument) and call the appropriate remote
        service method using `await self.blocking_call`

        Args:
            remote_service_proxy: The remote service proxy

        Returns:
            A tuple (status, response).
            - status (int): The HTTP status code to set (e.g., 200, 204).
            - response (dict or None): The data to return as JSON, or None.
        """
        raise NotImplementedError()

# ---------------------------------------------------------------------------
# WebSocket Handler
# ---------------------------------------------------------------------------


class WebSocketHandler(tornado.websocket.WebSocketHandler):
    clients = set()

    async def blocking_call(self, func, *args, **kwargs):
        return await tornado.ioloop.IOLoop.current().run_in_executor(
            self.application.executor,
            functools.partial(func, *args, **kwargs)
        )

    async def _initialize(self):
        @remote_call
        def query(mtda):
            messages = []

            version = mtda.agent_version()
            messages.append({"mtda-version": {"version": version}})

            console_output = mtda.console_dump()
            messages.append({"console-output": {"output": console_output}})

            power_status = mtda.target_status()
            messages.append({"POWER": {"event": power_status}})

            status, _, _ = mtda.storage_status()
            messages.append({"STORAGE": {"event": status}})

            fmt = mtda.video_format()
            if fmt is not None:
                from urllib.parse import urlparse
                url = urlparse(f'http://{self.request.host}')
                video_url = mtda.video_url(host=url.hostname)
                messages.append(
                        {"video-info": {"format": fmt, "url": video_url}}
                )

            return messages

        try:
            messages = await self.blocking_call(query)
            for msg in messages:
                logger.debug(f"www.ws.open: send {msg}")
                self.write_message(msg)

        except PyroErrors.TimeoutError:
            logger.warning("timeout during WebSocket for session "
                           f"{self.session_id}.")
            self.write_message({"error": "timeout during WebSocket "
                                "initialization"})
        except Exception as e:
            logger.exception("Error during WebSocket initialization "
                             f"for session {self.session_id}: {e}")
            self.write_message({"error": "Failed to initialize WebSocket: "
                                f"{e}"})

    def open(self):
        self.session_id = uuid.uuid4().hex
        logger.debug(f"www.ws.open(sid={self.session_id}")
        self.set_nodelay(True)
        WebSocketHandler.clients.add(self)
        self.write_message({"session": {"id": self.session_id}})
        tornado.ioloop.IOLoop.current().add_callback(self._initialize)

    def on_message(self, message):
        @remote_call
        def console_send(mtda, data, session):
            mtda.console_send(data, raw=False, session=session)

        sid = self.session_id
        if isinstance(message, bytes):
            logger.debug(f"www.ws.on_message({len(message)} bytes, "
                         f"session={sid})")
            sockets = self.application.settings['sockets']
            if sid in sockets:
                sockets[sid].send(message)
            else:
                logger.debug(f'no data socket for session {sid}!')
        else:
            logger.debug(f"www.ws.on_message(message={message})")
            data = tornado.escape.json_decode(message)
            logger.debug(f"www.ws.on_message(data={data})")
            if 'console-input' in data:
                data = data['console-input']['input']
                try:
                    tornado.ioloop.IOLoop.current().add_callback(
                            console_send, data, sid
                    )
                except PyroErrors.TimeoutError:
                    logger.warning("timeout for console_send "
                                   f"for session {sid}.")
                    self.write_message(
                            {"error": "console send timed out"}
                    )
                except Exception as e:
                    logger.exception("Error sending console input "
                                     f"for session {sid}: {e}")
                    self.write_message(
                            {"error": "Error sending console"
                                      f"console input: {e}"}
                    )

    def on_close(self):
        WebSocketHandler.clients.remove(self)

# ---------------------------------------------------------------------------
# /console-clear
# ---------------------------------------------------------------------------


class ConsoleClearHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Clear the console ring buffer",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "204": {
                "description": "Console ring buffer cleared"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def console_clear(mtda, session):
            mtda.console_clear(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(console_clear, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /console-dump
# ---------------------------------------------------------------------------


class ConsoleDumpHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Dump contents of the console ring buffer",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "Console ring buffer returned"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def console_dump(mtda, session):
            return mtda.console_dump(session=session)

        sid = self.get_argument('session')
        content = await self.blocking_call(console_dump, session=sid)
        return 200, {"content": content}

# ---------------------------------------------------------------------------
# /console-flush
# ---------------------------------------------------------------------------


class ConsoleFlushHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Flush and return previous contents of the console "
                   "ring buffer",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "Console ring buffer returned (and cleared)"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def console_flush(mtda, session):
            return mtda.console_flush(session=session)

        sid = self.get_argument('session')
        content = await self.blocking_call(console_flush, session=sid)
        return 200, {"content": content}

# ---------------------------------------------------------------------------
# /console-head
# ---------------------------------------------------------------------------


class ConsoleHeadHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Get the first line from the console ring-buffer",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "First line of the console ring buffer returned"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def console_head(mtda, session):
            return mtda.console_head(session=session)

        sid = self.get_argument('session')
        content = await self.blocking_call(console_head, session=sid)
        return 200, {"content": content}

# ---------------------------------------------------------------------------
# /console-lines
# ---------------------------------------------------------------------------


class ConsoleLinesHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Get the number of lines available in the console "
                   "ring-buffer",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "Number of lines returned"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def console_lines(mtda, session):
            return mtda.console_lines(session=session)

        sid = self.get_argument('session')
        count = await self.blocking_call(console_lines, session=sid)
        return 200, {"count": count}

# ---------------------------------------------------------------------------
# /console-send
# ---------------------------------------------------------------------------


class ConsoleSendHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Get the number of lines available in the console "
                   "ring-buffer",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }, {
            "name": "what",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "text to send to the console"
        }], "responses": {
            "204": {
                "description": "Text sent to the console"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def console_send(mtda, session):
            return mtda.console_send(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(console_send, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /console-tail
# ---------------------------------------------------------------------------


class ConsoleTailHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Get the last line from the console ring-buffer",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "Last line of the console ring buffer returned"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def console_tail(mtda, session):
            return mtda.console_tail(session=session)

        sid = self.get_argument('session')
        content = await self.blocking_call(console_tail, session=sid)
        return 200, {"content": content}

# ---------------------------------------------------------------------------
# /keyboard-input
# ---------------------------------------------------------------------------


class KeyboardInputHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Send keyboard input",
        "parameters": [{
            "name": "input",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "Key to be pressed"
        }, {
            "name": "shift",
            "in": "query",
            "required": False,
            "schema": {
                "type": "boolean",
                "default": False
            },
            "description": "Whether shift modifier is pressed"
        }, {
            "name": "ctrl",
            "in": "query",
            "required": False,
            "schema": {
                "type": "boolean",
                "default": False
            },
            "description": "Whether ctrl modifier is pressed"
        }, {
            "name": "alt",
            "in": "query",
            "required": False,
            "schema": {
                "type": "boolean",
                "default": False
            },
            "description": "Whether alt modifier is pressed"
        }, {
            "name": "meta",
            "in": "query",
            "required": False,
            "schema": {
                "type": "boolean",
                "default": False
            },
            "description": "Whether meta modifier is pressed"
        }], "responses": {
            "204": {
                "description": "Key press event sent"
            },
            "400": {
                "description": "Invalid input parameter"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def keyboard_press(mtda, key, ctrl, shift, alt, meta, session):
            mtda.keyboard_press(key, ctrl=ctrl, shift=shift, alt=alt,
                                meta=meta, session=session)

        input_key = self.get_argument("input", "")
        sid = self.get_argument('session', None)

        key_map = {
            "esc": "<esc>",
            "f1": "<f1>", "f2": "<f2>", "f3": "<f3>", "f4": "<f4>",
            "f5": "<f5>", "f6": "<f6>", "f7": "<f7>", "f8": "<f8>",
            "f9": "<f9>", "f10": "<f10>", "f11": "<f11>", "f12": "<12>",
            "\b": "<backspace>", "    ": "<tab>", "caps": "<capslock>",
            "\n": "<enter>",
            "left": "<left>", "right": "<right>",
            "up": "<up>", "down": "<down>",
            "<space>": " "
        }

        if input_key in key_map:
            input_key = key_map[input_key]

        shift = self.get_argument('shift', 'false') == 'true'
        if input_key.isupper() and shift is False:
            input_key = input_key.lower()
            shift = True

        await self.blocking_call(
                keyboard_press,
                input_key,
                ctrl=self.get_argument('ctrl', 'false') == 'true',
                shift=shift,
                alt=self.get_argument('alt', 'false') == 'true',
                meta=self.get_argument('meta', 'false') == 'true',
                session=sid
        )
        return 204, None

# ---------------------------------------------------------------------------
# /mouse-event
# ---------------------------------------------------------------------------


class MouseEventHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Send a mouse move event",
        "parameters": [{
            "name": "x",
            "in": "query",
            "required": False,
            "schema": {
                "type": "number",
                "default": 0
            },
            "description": "X coordinate as a percentage"
        }, {
            "name": "y",
            "in": "query",
            "required": False,
            "schema": {
                "type": "number",
                "default": 0
            },
            "description": "Y coordinate as a percentage"
        }, {
            "name": "buttons",
            "in": "query",
            "required": False,
            "schema": {
                "type": "number",
                "default": 0
            },
            "description": "bitmask of buttons pressed"
        }], "responses": {
            "204": {
                "description": "Mouse event sent"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def mouse_move(mtda, x, y, buttons, session):
            mtda.mouse_move(x, y, buttons, session=session)
            if buttons > 0:
                mtda.mouse_move(x, y, 0, session=session)

        sid = self.get_argument('session', None)
        x = float(self.get_argument("x", 0))
        y = float(self.get_argument("y", 0))
        buttons = int(self.get_argument("buttons", 0))

        await self.blocking_call(mouse_move, x, y, buttons, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /power-toggle
# ---------------------------------------------------------------------------


class PowerToggleHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Toggle power for the Device Under Test",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "Power toggled"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def target_toggle(mtda, session):
            return mtda.target_toggle(session=session)

        sid = self.get_argument('session')
        status = await self.blocking_call(target_toggle, session=sid)
        return 200, {"status": status}

# ---------------------------------------------------------------------------
# /storage-open
# ---------------------------------------------------------------------------


class StorageOpenHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Open the shared storage to upload a file",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }, {
            "name": "file",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "name of the file to be uploaded"
        }, {
            "name": "size",
            "in": "query",
            "required": False,
            "schema": {
                "type": "number",
                "default": 0
            },
            "description": "size of the file in bytes"
        }], "responses": {
            "204": {
                "description": "Storage opened"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self, mtda):
        compr = CONSTS.IMAGE.RAW.value
        file = self.get_argument('file')
        try:
            size = int(self.get_argument('size', 0))
        except ValueError:
            size = 0
        if file:
            logger.debug(f'file to be uploaded: {file}')
            compr = Compression.from_extension(file)
            await self.blocking_call(mtda.storage_compression, compr)

        sid = self.get_argument('session')
        zmq_socket = await self.blocking_call(
            mtda.storage_open, size, session=sid
        )
        self.application.settings['sockets'][sid] = zmq_socket
        return 204, None

# ---------------------------------------------------------------------------
# /storage-close
# ---------------------------------------------------------------------------


class StorageCloseHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Close (release) shared storage",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "204": {
                "description": "Shared storage closed"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def storage_close(mtda, session):
            mtda.storage_close(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(storage_close, session=sid)
        if sid in self.application.settings['sockets']:
            del self.application.settings['sockets'][sid]
        return 204, None

# ---------------------------------------------------------------------------
# /storage-commit
# ---------------------------------------------------------------------------


class StorageCommitHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Commit changes made to the shared storage",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "204": {
                "description": "Changes to the shared storage committed to disk"
            },
            "400": {
                "description": "Invalid input parameters"
            },
            "500": {
                "description": "Changes to the shared storage could not be "
                               "committed to disk"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def storage_commit(mtda, session):
            mtda.storage_commit(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(storage_commit, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /storage-rollback
# ---------------------------------------------------------------------------


class StorageRollbackHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Rollback changes made to the shared storage",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "204": {
                "description": "Changes to the shared storage were rolled "
                               "back"
            },
            "400": {
                "description": "Invalid input parameters"
            },
            "500": {
                "description": "Changes to the shared storage could not be "
                               "rolled back"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def storage_rollback(mtda, session):
            mtda.storage_rollback(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(storage_rollback, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /storage-toggle
# ---------------------------------------------------------------------------


class StorageToggleHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Toggle storage between the host and device",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "Storage toggled"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def storage_toggle(mtda, session):
            return mtda.storage_toggle(session=session)

        sid = self.get_argument('session')
        status = await self.blocking_call(storage_toggle, session=sid)
        return 200, {"status": status}

# ---------------------------------------------------------------------------
# /storage-to-host
# ---------------------------------------------------------------------------


class StorageToHostHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Transfer shared storage to the HOST",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "204": {
                "description": "Shared storage on HOST"
            },
            "400": {
                "description": "Invalid input parameters"
            },
            "405": {
                "description": "Shared storage could not be transferred "
                               "to HOST"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def storage_to_host(mtda, session):
            mtda.storage_to_host(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(storage_to_host, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /storage-to-target
# ---------------------------------------------------------------------------


class StorageToTargetHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Transfer shared storage to the TARGET",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "204": {
                "description": "Shared storage on HOST"
            },
            "400": {
                "description": "Invalid input parameters"
            },
            "405": {
                "description": "Shared storage could not be transferred "
                               "to TARGET"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def storage_to_target(mtda, session):
            mtda.storage_to_target(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(storage_to_target, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /target-off
# ---------------------------------------------------------------------------


class TargetOffHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Turn OFF the target device",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "204": {
                "description": "Target powered OFF"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def target_off(mtda, session):
            mtda.target_off(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(target_off, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /target-on
# ---------------------------------------------------------------------------


class TargetOnHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Turn ON the target device",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "204": {
                "description": "Target powered ON"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def target_on(mtda, session):
            mtda.target_on(session=session)

        sid = self.get_argument('session')
        await self.blocking_call(target_on, session=sid)
        return 204, None

# ---------------------------------------------------------------------------
# /target-status
# ---------------------------------------------------------------------------


class TargetStatusHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Query state of the target device (ON or OFF)",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "Status of the target device"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def target_status(mtda, session):
            return mtda.target_status(session=session)

        sid = self.get_argument('session')
        status = await self.blocking_call(target_status, session=sid)
        return 200, {"status": status}

# ---------------------------------------------------------------------------
# /target-uptime
# ---------------------------------------------------------------------------


class TargetUptimeHandler(RemoteCallHandler):
    spec = {"get": {
        "summary": "Query the uptime of the target device",
        "parameters": [{
            "name": "session",
            "in": "query",
            "required": True,
            "schema": {"type": "string"},
            "description": "session ID"
        }], "responses": {
            "200": {
                "description": "Uptime of the target device (in seconds)"
            },
            "400": {
                "description": "Invalid input parameters"
            }
        }}}

    async def _handle_remote_request(self):
        @remote_call
        def target_uptime(mtda, session):
            return mtda.target_uptime(session=session)

        sid = self.get_argument('session')
        uptime = await self.blocking_call(target_uptime, session=sid)
        return 200, {"uptime": uptime}


class WebConsole(RemoteConsole):
    def _context(self):
        return zmq.asyncio.Context()

    async def reader(self):
        self.connect()
        try:
            while self.exiting is False:
                topic, data = await self.socket.recv_multipart()
                self.dispatch(topic, data)
        except zmq.error.ContextTerminated:
            self.socket = None


class WebMonitor(WebConsole):
    def __init__(self, host, port, screen):
        super().__init__(host, port, screen)
        self.topic = CONSTS.CHANNEL.MONITOR

    def _subscribe(self):
        super()._subscribe()
        self.socket.setsockopt(zmq.SUBSCRIBE, CONSTS.CHANNEL.EVENTS)


class WebOutput(ScreenOutput):
    def __init__(self, application, mtda):
        self.application = application
        super().__init__(mtda)

    def _send_to_clients(self, message):
        for client in WebSocketHandler.clients:
            client.write_message(message)

    def on_event(self, event):
        info = event.split()
        domain = info[0]

        if domain == 'SESSION':
            self.session_event(info[1:])

        message = {domain: {"event": ' '.join(info[1:])}}
        loop = tornado.ioloop.IOLoop.current()
        loop.add_callback(self._send_to_clients, message)

    def session_event(self, info):
        if info[0] == 'INACTIVE':
            sid = info[1]
            if sid in self.application.settings['sockets']:
                del self.application.settings['sockets'][sid]

    def write(self, data):
        data = base64.b64encode(data).decode('utf-8')
        message = {"console-output": {"output": data}}
        loop = tornado.ioloop.IOLoop.current()
        loop.add_callback(self._send_to_clients, message)

# ---------------------------------------------------------------------------
# OpenAPI / Swagger UI Handlers
# ---------------------------------------------------------------------------


class OpenAPIHandler(RemoteCallHandler):
    async def get(self):
        @remote_call
        def agent_version(mtda):
            return mtda.agent_version()

        self.set_header("Content-Type", "application/json")
        try:
            version = await self.blocking_call(agent_version)
            spec = {
                "openapi": "3.0.0",
                "info": {
                    "title": "MTDA API",
                    "version": version,
                    "description": "MTDA Web Service API"
                },
                "paths": {
                    "/console-clear": ConsoleClearHandler.spec,
                    "/console-dump": ConsoleDumpHandler.spec,
                    "/console-flush": ConsoleFlushHandler.spec,
                    "/console-head": ConsoleHeadHandler.spec,
                    "/console-lines": ConsoleLinesHandler.spec,
                    "/console-send": ConsoleSendHandler.spec,
                    "/console-tail": ConsoleTailHandler.spec,
                    "/keyboard-input": KeyboardInputHandler.spec,
                    "/mouse-move": MouseEventHandler.spec,
                    "/power-toggle": PowerToggleHandler.spec,
                    "/storage-open": StorageOpenHandler.spec,
                    "/storage-close": StorageCloseHandler.spec,
                    "/storage-commit": StorageCommitHandler.spec,
                    "/storage-rollback": StorageRollbackHandler.spec,
                    "/storage-toggle": StorageToggleHandler.spec,
                    "/storage-to-host": StorageToHostHandler.spec,
                    "/storage-to-target": StorageToTargetHandler.spec,
                    "/target-off": TargetOffHandler.spec,
                    "/target-on": TargetOnHandler.spec,
                    "/target-status": TargetStatusHandler.spec,
                    "/target-uptime": TargetUptimeHandler.spec
                }
            }
            self.write(spec)
        except PyroErrors.TimeoutError:
            logger.warning("Pyro4 timeout fetching agent version for OpenAPI.")
            self.set_status(504)
            self.write({"error": "timeout while fetching API version"})
        except Exception as e:
            logger.exception(f"Error fetching service version: {e}")
            self.set_status(500)
            self.write({"error": f"An internal server error occurred: {e}"})
        self.finish()


class SwaggerUIHandler(tornado.web.RequestHandler):
    def get(self):
        self.render("swagger.html")

# ---------------------------------------------------------------------------
# Main Service Application
# ---------------------------------------------------------------------------


class Service:
    def __init__(self):
        self.mtda = Client('localhost')

    def parse_args(self):
        parser = argparse.ArgumentParser(description='mtda.www settings')
        parser.add_argument(
                '--debug',
                action='store_true',
                help='Enable debug logs')
        parser.add_argument(
                "--host",
                type=str,
                default=CONSTS.DEFAULTS.WWW_HOST)
        parser.add_argument(
                "--port",
                type=int,
                default=CONSTS.DEFAULTS.WWW_PORT)
        parser.add_argument(
                "--workers",
                type=int,
                default=CONSTS.DEFAULTS.WWW_WORKERS)
        args = parser.parse_args()
        if args.debug:
            logger.setLevel(logging.DEBUG)
        self._host = args.host
        self._port = args.port
        self._workers = args.workers

    async def blocking_call(self, func, *args, **kwargs):
        return await tornado.ioloop.IOLoop.current().run_in_executor(
            self.application.executor,
            functools.partial(func, *args, **kwargs)
        )

    async def run(self):
        @remote_call
        def console_port(mtda):
            return mtda.console_port()

        @remote_call
        def mtda_remote(mtda):
            return mtda.remote()

        @remote_call
        def mtda_start(mtda):
            mtda.start()

        self.parse_args()
        self.executor = concurrent.futures.ThreadPoolExecutor(
                max_workers=self._workers
        )
        BASE_DIR = os.path.dirname(os.path.abspath(CONSTS.__file__))
        self.application = tornado.web.Application([
            (r"/", MainHandler),
            (r"/api/docs", OpenAPIHandler),
            (r"/api/swagger", SwaggerUIHandler),
            (r"/assets/(.*)", AssetsHandler, {
                "path": os.path.join(BASE_DIR, "assets")
            }),
            (r"/novnc/(.*)", NoVNCHandler, {
                "path": "/usr/share/novnc"
            }),
            (r"/pyodide/(.*)", PyodideHandler, {
                "path": "/opt/pyodide"
            }),
            (r"/whl/(.*)", PyodideHandler, {
                "path": "/opt/whl"
            }),
            (r"/mtda", WebSocketHandler),
            (r"/console-clear", ConsoleClearHandler),
            (r"/console-dump", ConsoleDumpHandler),
            (r"/console-flush", ConsoleFlushHandler),
            (r"/console-head", ConsoleHeadHandler),
            (r"/console-lines", ConsoleLinesHandler),
            (r"/console-send", ConsoleSendHandler),
            (r"/console-tail", ConsoleTailHandler),
            (r"/keyboard-input", KeyboardInputHandler),
            (r"/mouse-move", MouseEventHandler),
            (r"/power-toggle", PowerToggleHandler),
            (r"/storage-close", StorageCloseHandler),
            (r"/storage-commit", StorageCommitHandler),
            (r"/storage-open", StorageOpenHandler),
            (r"/storage-rollback", StorageRollbackHandler),
            (r"/storage-toggle", StorageToggleHandler),
            (r"/storage-to-host", StorageToHostHandler),
            (r"/storage-to-target", StorageToTargetHandler),
            (r"/target-off", TargetOffHandler),
            (r"/target-on", TargetOnHandler),
            (r"/target-status", TargetStatusHandler),
            (r"/target-uptime", TargetUptimeHandler),
        ], template_path=os.path.join(BASE_DIR, "templates"),
           executor=self.executor, mtda=self.mtda, sockets={}, debug=False)

        # Pass the executor to the application settings for our handlers
        self.application.executor = self.executor

        # Connect both the console and monitor to our custom output
        try:
            conport = await self.blocking_call(console_port)
            remote = await self.blocking_call(mtda_remote)
            output = WebOutput(self.application, self.mtda)
            console = WebConsole(remote, conport, output)
            asyncio.create_task(console.reader())
            monitor = WebMonitor(remote, conport, output)
            asyncio.create_task(monitor.reader())
        except Exception as e:
            logger.error(f"Failed to initialize MTDA console/monitor: {e}")
            raise

        try:
            await self.blocking_call(mtda_start)
        except Exception as e:
            logger.error(f"Failed to start MTDA client: {e}")
            raise

        self.application.listen(self._port, self._host)
        logger.info("www server listening on "
                    f"http://{self._host}:{self._port}")
        await asyncio.Event().wait()


if __name__ == '__main__':
    srv = Service()
    asyncio.run(srv.run())
